# PLAID INTEGRATION PLAN FOR NET WORTH TRACKER
# A Complete Guide for Junior Engineers

================================================================================
TABLE OF CONTENTS
================================================================================
1. OVERVIEW & LEARNING OBJECTIVES
2. UNDERSTANDING PLAID (What is it? How does it work?)
3. PROJECT ARCHITECTURE DECISIONS
4. PHASE-BY-PHASE IMPLEMENTATION PLAN
5. TROUBLESHOOTING & COMMON ISSUES
6. RESOURCES & DOCUMENTATION

================================================================================
1. OVERVIEW & LEARNING OBJECTIVES
================================================================================

üéØ GOAL: Give users the choice to either manually enter asset/liability values OR connect them to their bank accounts via Plaid for automatic syncing

üß† WHAT YOU'LL LEARN:
- How financial APIs work (Plaid specifically)
- OAuth-like flows (Link token ‚Üí Public token ‚Üí Access token)
- Database schema design for third-party integrations
- React component patterns for external widgets
- Error handling for external services
- Token management and security best practices

üí° WHY PLAID?
- Connects to 11,000+ financial institutions
- Handles authentication securely (you never see passwords)
- Provides real-time balance data
- Industry standard for fintech apps

================================================================================
2. UNDERSTANDING PLAID (What is it? How does it work?)
================================================================================

üîç PLAID BASICS:
Plaid is a "financial data network" - think of it as a secure bridge between your app and banks.

üìä THE FLOW:
1. User clicks "Connect Bank Account" in your app
2. Plaid Link widget opens (hosted by Plaid)
3. User enters their bank credentials (Plaid sees this, not you)
4. Bank authenticates user
5. Plaid returns a "public_token" to your app
6. Your backend exchanges public_token for "access_token"
7. You store access_token securely
8. Use access_token to fetch balances anytime

üîê SECURITY NOTES (SIMPLIFIED FOR PERSONAL USE):
- You never see user bank passwords
- Access tokens are encrypted before storage (recommended by Plaid)
- Plaid is bank-grade security (SOC 2, ISO 27001)
- Tokens can be revoked by user anytime
- Basic input validation prevents app crashes
- Supabase RLS handles user data separation

================================================================================
3. PROJECT ARCHITECTURE DECISIONS
================================================================================

üèóÔ∏è HOW WE'LL STRUCTURE THIS:

CURRENT STATE:
- Manual asset/liability tracking
- Static values entered by user
- Simple CRUD operations

TARGET STATE:
- User choice workflow: Manual entry OR Plaid linking per asset/liability
- Seamless integration within existing forms
- Real-time balance updates for connected accounts
- Clear visual indicators showing sync status

üóÑÔ∏è DATABASE CHANGES:
We'll enhance your existing Asset and Liability tables with optional Plaid fields.
No separate tables needed - everything stays unified with optional bank linking.

üìÅ FILE STRUCTURE (SIMPLIFIED):
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ plaid.ts (‚úÖ exists, needs enhancement)
‚îÇ   ‚îú‚îÄ‚îÄ plaid-sync.ts (new - balance syncing logic)
‚îÇ   ‚îú‚îÄ‚îÄ assets.ts (enhance with Plaid functions)
‚îÇ   ‚îú‚îÄ‚îÄ liabilities.ts (enhance with Plaid functions)
‚îÇ   ‚îî‚îÄ‚îÄ crypto.ts (new - simple token encryption)
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ PlaidLinkButton.tsx (new - embedded in forms)
‚îÇ   ‚îú‚îÄ‚îÄ AssetForm.tsx (enhance with Plaid choice)
‚îÇ   ‚îî‚îÄ‚îÄ LiabilityForm.tsx (enhance with Plaid choice)
‚îî‚îÄ‚îÄ app/
    ‚îî‚îÄ‚îÄ actions.ts (enhance with Plaid actions)

================================================================================
4. PHASE-BY-PHASE IMPLEMENTATION PLAN
================================================================================

‚ñ∂Ô∏è PHASE 1: DATABASE FOUNDATION (Day 1 - 1-2 hours)
================================================================================

üéØ Goal: Enhance existing Asset/Liability tables to support optional Plaid linking

üìù WHAT WE'RE DOING:
Adding Plaid-related fields to your existing Asset and Liability models.
This keeps everything unified while adding optional bank account syncing.

üß† LEARNING FOCUS:
- Database schema evolution
- Optional fields and nullable columns
- Backwards compatibility in migrations

‚úÖ TASKS:
1. Add Plaid fields to existing Asset and Liability models
2. Run migration
3. Update TypeScript types
4. Test existing functionality still works

üìã DETAILED STEPS:

Step 1.1: Update prisma/schema.prisma
```prisma
// Enhance existing Asset model with optional Plaid fields
model Asset {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name             String
  category         String
  value            Decimal  @db.Decimal(15, 2)
  description      String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  userId           String   @db.Uuid

  // NEW: Optional Plaid integration fields (SIMPLIFIED)
  plaidAccountId   String?                     // Plaid's account ID (if linked)
  plaidAccessToken String?                     // üîê ENCRYPTED access token
  plaidTokenIv     String?                     // üîê Encryption IV
  institutionName  String?                     // Bank name (e.g., "Chase")
  isPlaidSynced    Boolean  @default(false)    // Is this auto-synced from bank?
  lastSyncedAt     DateTime?                   // When was balance last updated?

  @@map("assets")
  @@index([userId, isPlaidSynced])             // Performance index
}

// Enhance existing Liability model with optional Plaid fields
model Liability {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name             String
  category         String
  value            Decimal  @db.Decimal(15, 2)
  description      String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  userId           String   @db.Uuid

  // NEW: Optional Plaid integration fields (SIMPLIFIED)
  plaidAccountId   String?                     // Plaid's account ID (if linked)
  plaidAccessToken String?                     // üîê ENCRYPTED access token
  plaidTokenIv     String?                     // üîê Encryption IV
  institutionName  String?                     // Bank name (e.g., "Chase")
  isPlaidSynced    Boolean  @default(false)    // Is this auto-synced from bank?
  lastSyncedAt     DateTime?                   // When was balance last updated?

  @@map("liabilities")
  @@index([userId, isPlaidSynced])             // Performance index
}
```

üß† WHY THIS DESIGN?
- No separate tables - everything stays unified in existing Asset/Liability models
- Optional Plaid fields mean existing manual entries are unaffected
- Each asset/liability can be either manual OR Plaid-synced individually
- Boolean flags make it easy to distinguish and handle different types
- Simple migration that doesn't break existing data

Step 1.2: Create and run migration
```bash
npx prisma migrate dev --name add_plaid_fields_to_assets_liabilities
```

Step 1.3: Create src/lib/crypto.ts (NEW - Simple Token Encryption)
```typescript
// üîê Simple AES-256 encryption for Plaid access tokens
import crypto from 'crypto';

const ENCRYPTION_KEY = process.env.PLAID_ENCRYPTION_KEY!;
const ALGORITHM = 'aes-256-cbc';

if (!ENCRYPTION_KEY || ENCRYPTION_KEY.length !== 64) {
  throw new Error('PLAID_ENCRYPTION_KEY must be a 64-character hex string');
}

const key = Buffer.from(ENCRYPTION_KEY, 'hex');

export function encryptToken(token: string): { encrypted: string; iv: string } {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(ALGORITHM, key);

  let encrypted = cipher.update(token, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  return {
    encrypted,
    iv: iv.toString('hex')
  };
}

export function decryptToken(encrypted: string, iv: string): string {
  const decipher = crypto.createDecipher(ALGORITHM, key);
  decipher.setIV(Buffer.from(iv, 'hex'));

  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}

// Generate encryption key for setup
export function generateEncryptionKey(): string {
  return crypto.randomBytes(32).toString('hex');
}
```

Step 1.4: Update TypeScript types in src/lib/assets.ts
```typescript
// Enhanced types for assets with optional Plaid integration
export type CreateAssetData = {
  name: string
  category: string
  value: number
  description?: string
  // NEW: Optional Plaid fields
  plaidAccountId?: string
  plaidAccessToken?: string  // Will be encrypted before storage
  institutionName?: string
  isPlaidSynced?: boolean
}

export type UpdateAssetData = {
  name?: string
  category?: string
  value?: number
  description?: string
  // NEW: Optional Plaid fields for updates
  plaidAccountId?: string
  plaidAccessToken?: string
  plaidTokenIv?: string
  institutionName?: string
  isPlaidSynced?: boolean
  lastSyncedAt?: Date
}
```

üö® GOTCHAS TO WATCH FOR:
- Make sure your DATABASE_URL is set correctly
- If migration fails, check for syntax errors in schema
- Remember to restart your dev server after schema changes
- Generate and set PLAID_ENCRYPTION_KEY before running migration

‚ñ∂Ô∏è PHASE 2: PLAID CLIENT ENHANCEMENT (Day 1-2 - 2-3 hours)
================================================================================

üéØ Goal: Build robust Plaid integration functions

üìù WHAT WE'RE DOING:
Enhancing your existing Plaid client with functions to handle the complete flow.

üß† LEARNING FOCUS:
- API client patterns
- Token exchange flows
- Error handling strategies
- Environment configuration

‚úÖ TASKS:
1. Enhance src/lib/plaid.ts with new functions
2. Create src/lib/plaid-accounts.ts for database operations
3. Add environment variables
4. Test basic connectivity

üìã DETAILED STEPS:

Step 2.1: Enhance src/lib/plaid.ts (SIMPLIFIED)
```typescript
import {
  Configuration,
  PlaidApi,
  PlaidEnvironments,
  LinkTokenCreateRequest,
  ItemPublicTokenExchangeRequest,
  AccountsBalanceGetRequest,
  CountryCode,
  Products
} from 'plaid';

const config = new Configuration({
  basePath: PlaidEnvironments[process.env.PLAID_ENV as keyof typeof PlaidEnvironments] || PlaidEnvironments.sandbox,
  baseOptions: {
    headers: {
      'PLAID-CLIENT-ID': process.env.PLAID_CLIENT_ID!,
      'PLAID-SECRET': process.env.PLAID_SECRET!,
    },
  },
});

export const plaidClient = new PlaidApi(config);

// üß† LEARNING: Link tokens are short-lived tokens that initialize Plaid Link
export async function createLinkToken(userId: string) {
  try {
    const request: LinkTokenCreateRequest = {
      user: {
        client_user_id: userId,
      },
      client_name: 'Net Worth Tracker',
      products: [Products.Transactions],
      country_codes: [CountryCode.Us],
      language: 'en',
    };

    const response = await plaidClient.linkTokenCreate(request);
    return response.data.link_token;
  } catch (error) {
    console.error('Error creating link token:', error);
    throw new Error('Failed to create link token');
  }
}

// üß† LEARNING: Exchange public token (from Link) for access token (permanent)
export async function exchangePublicToken(publicToken: string) {
  try {
    const request: ItemPublicTokenExchangeRequest = {
      public_token: publicToken,
    };

    const response = await plaidClient.itemPublicTokenExchange(request);
    return {
      accessToken: response.data.access_token,
      itemId: response.data.item_id,
    };
  } catch (error) {
    console.error('Error exchanging public token:', error);
    throw new Error('Failed to exchange public token');
  }
}

// üß† LEARNING: This fetches real-time balances from the bank
export async function getAccountBalances(accessToken: string) {
  try {
    const request: AccountsBalanceGetRequest = {
      access_token: accessToken,
    };

    const response = await plaidClient.accountsBalanceGet(request);
    return response.data.accounts;
  } catch (error) {
    console.error('Error fetching account balances:', error);
    throw new Error('Failed to fetch account balances');
  }
}

// üß† LEARNING: Get account details (institution info, account names, etc.)
export async function getAccounts(accessToken: string) {
  try {
    const request = {
      access_token: accessToken,
    };

    const response = await plaidClient.accountsGet(request);
    return response.data;
  } catch (error) {
    console.error('Error fetching accounts:', error);
    throw new Error('Failed to fetch accounts');
  }
}
```

Step 2.2: Update .env file (SIMPLIFIED)
```env
# Add these Plaid variables (you'll get these from Plaid Dashboard)
PLAID_CLIENT_ID=your_client_id_here
PLAID_SECRET=your_secret_here
PLAID_ENV=sandbox

# Token encryption (generate with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))")
PLAID_ENCRYPTION_KEY=your_64_char_hex_encryption_key_here
```

**Generate your encryption key:**
```bash
node -e "console.log('PLAID_ENCRYPTION_KEY=' + require('crypto').randomBytes(32).toString('hex'))"
```
üß† LEARNING NOTES:
- Access tokens are what you use for all API calls after initial connection
- Link tokens expire quickly (30 minutes) - they're just for the initial flow
- Access tokens are now encrypted before storage (recommended by Plaid)
- Supabase RLS automatically handles user data separation
- Basic validation prevents app crashes from bad data

‚ñ∂Ô∏è PHASE 3: ENHANCED FORMS WITH PLAID (Day 2-3 - 2-3 hours)
================================================================================

üéØ Goal: Add Plaid connection option to existing Asset and Liability forms

üìù WHAT WE'RE DOING:
Enhancing your existing AssetForm and LiabilityForm components to give users the choice:
"Enter value manually" OR "Link to your bank account"

‚úÖ TASKS:
1. Install Plaid Link SDK
2. Create PlaidLinkButton component
3. Enhance existing forms with Plaid choice
4. Handle both manual and Plaid creation flows

Step 3.1: Install Plaid Link for React
```bash
npm install react-plaid-link
npm install @types/react-plaid-link --save-dev
```

Step 3.2: Create src/components/PlaidLinkButton.tsx (SIMPLIFIED)
```typescript
'use client'

import { usePlaidLink } from 'react-plaid-link';
import { Button } from '@/components/ui/button';
import { useState } from 'react';

interface PlaidLinkButtonProps {
  linkToken: string | null;
  onSuccess: (public_token: string, metadata: any) => void;
  onError?: (error: any) => void;
  buttonText?: string;
  className?: string;
}

export function PlaidLinkButton({
  linkToken,
  onSuccess,
  onError,
  buttonText = "Link to Bank Account",
  className
}: PlaidLinkButtonProps) {
  const [isLoading, setIsLoading] = useState(false);

  const { open, ready } = usePlaidLink({
    token: linkToken,
    onSuccess: (public_token, metadata) => {
      setIsLoading(true);
      onSuccess(public_token, metadata);
    },
    onExit: (err, metadata) => {
      setIsLoading(false);
      if (err) {
        console.error('Plaid Link exit error:', err);
        onError?.(err);
      }
    },
  });

  return (
    <Button
      type="button"
      onClick={() => open()}
      disabled={!ready || !linkToken || isLoading}
      variant="outline"
      className={className}
    >
      {isLoading ? 'Connecting...' : buttonText}
    </Button>
  );
}
```

Step 3.3: Create server actions in src/app/actions.ts (SIMPLIFIED)
```typescript
// Add these imports to the top
import { createLinkToken, exchangePublicToken, getAccounts, getAccountBalances } from '@/lib/plaid';
import { encryptToken } from '@/lib/crypto';

// Server actions run on the server but can be called from client components
export async function createPlaidLinkTokenAction() {
  try {
    const user = await getUser();
    if (!user) {
      return { success: false, error: 'Authentication required' };
    }

    const linkToken = await createLinkToken(user.id);
    return { success: true, linkToken };
  } catch (error) {
    console.error('Error creating link token:', error);
    return { success: false, error: 'Failed to create link token' };
  }
}

export async function exchangePlaidTokenAction(publicToken: string, metadata: any) {
  try {
    const user = await getUser();
    if (!user) {
      return { success: false, error: 'Authentication required' };
    }

    // Exchange public token for access token
    const { accessToken, itemId } = await exchangePublicToken(publicToken);

    // Get account details from Plaid
    const accountsData = await getAccounts(accessToken);

    // For each account, you can create assets/liabilities
    // This example just returns the connection data
    return {
      success: true,
      accessToken, // Will be encrypted when stored
      accounts: accountsData.accounts,
      institution: metadata.institution
    };
  } catch (error) {
    console.error('Error exchanging Plaid token:', error);
    return { success: false, error: 'Failed to connect account' };
  }
}
```

Step 3.4: Enhance src/components/AssetForm.tsx (SIMPLIFIED)
```typescript
// Add these imports
import { useState, useEffect } from 'react';
import { PlaidLinkButton } from './PlaidLinkButton';
import { createPlaidLinkTokenAction, exchangePlaidTokenAction } from '@/app/actions';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { encryptToken } from '@/lib/crypto';

// Add to your existing AssetForm component:
export function AssetForm({ onSubmit, onCancel }: AssetFormProps) {
  const [entryMode, setEntryMode] = useState<'manual' | 'plaid'>('manual');
  const [linkToken, setLinkToken] = useState<string | null>(null);
  const [plaidData, setPlaidData] = useState<any>(null);

  // Initialize link token when Plaid mode is selected
  useEffect(() => {
    async function initializeLinkToken() {
      if (entryMode === 'plaid' && !linkToken) {
        const result = await createPlaidLinkTokenAction();
        if (result.success) {
          setLinkToken(result.linkToken);
        }
      }
    }
    initializeLinkToken();
  }, [entryMode, linkToken]);

  const handlePlaidSuccess = async (publicToken: string, metadata: any) => {
    try {
      const result = await exchangePlaidTokenAction(publicToken, metadata);
      if (result.success) {
        setPlaidData(result);
        // Auto-fill form fields from Plaid data
        setValue('name', `${metadata.institution.name} ${metadata.accounts[0].name}`);
        setValue('value', 0); // Will be synced after connection
      }
    } catch (error) {
      console.error('Error processing Plaid connection:', error);
    }
  };

  const handleFormSubmit = async (data: any) => {
    if (entryMode === 'plaid' && plaidData) {
      // Encrypt access token before storage
      const { encrypted, iv } = encryptToken(plaidData.accessToken);

      // Create asset with Plaid data
      const assetData = {
        ...data,
        plaidAccountId: plaidData.accounts[0].account_id,
        plaidAccessToken: encrypted,
        plaidTokenIv: iv,
        institutionName: plaidData.institution.name,
        isPlaidSynced: true,
      };
      await onSubmit(assetData);
    } else {
      // Regular manual asset
      await onSubmit(data);
    }
  };

  return (
    <form onSubmit={handleSubmit(handleFormSubmit)}>
      {/* Choice between manual and Plaid */}
      <div className="mb-6">
        <Label className="text-base font-medium">How would you like to track this asset?</Label>
        <RadioGroup value={entryMode} onValueChange={(value) => setEntryMode(value as 'manual' | 'plaid')} className="mt-2">
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="manual" id="manual" />
            <Label htmlFor="manual">Enter value manually</Label>
          </div>
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="plaid" id="plaid" />
            <Label htmlFor="plaid">Link to bank account (auto-sync)</Label>
          </div>
        </RadioGroup>
      </div>

      {/* Rest of your form fields */}
      <div className="space-y-4">
        {/* Name field */}
        <div>
          <Label htmlFor="name">Asset Name</Label>
          <Input
            id="name"
            {...register('name', { required: 'Asset name is required' })}
          />
          {errors.name && <p className="text-red-500 text-sm">{errors.name.message}</p>}
        </div>

        {/* Conditional value input vs Plaid button */}
        {entryMode === 'manual' ? (
          <div>
            <Label htmlFor="value">Value</Label>
            <Input
              id="value"
              type="number"
              step="0.01"
              {...register('value', { required: 'Value is required' })}
            />
            {errors.value && <p className="text-red-500 text-sm">{errors.value.message}</p>}
          </div>
        ) : (
          <div>
            <Label>Bank Account Connection</Label>
            {plaidData ? (
              <div className="p-3 bg-green-50 border border-green-200 rounded">
                <p className="text-green-700">‚úÖ Connected to {plaidData.institution.name}</p>
                <p className="text-sm text-green-600">Balance will be automatically synced</p>
              </div>
            ) : (
              <PlaidLinkButton
                linkToken={linkToken}
                onSuccess={handlePlaidSuccess}
                buttonText="Connect to Bank Account"
                className="w-full"
              />
            )}
          </div>
        )}

        {/* Other form fields (category, description) */}
      </div>

      {/* Submit button */}
      <div className="flex gap-2 mt-6">
        <Button type="submit" disabled={entryMode === 'plaid' && !plaidData}>
          {entryMode === 'plaid' && !plaidData ? 'Connect Account First' : 'Create Asset'}
        </Button>
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancel
        </Button>
      </div>
    </form>
  );
}
```

üß† WHY THIS PATTERN?
- User chooses manual entry OR Plaid linking per asset/liability
- Plaid tokens are encrypted before database storage
- Form auto-fills with bank account information
- Simple error handling for a personal app
- Supabase RLS ensures users only see their own data

‚ñ∂Ô∏è PHASE 4: BALANCE SYNCING (Day 3-4 - 2-3 hours)
================================================================================

üéØ Goal: Sync balances for Plaid-connected assets/liabilities

Step 4.1: Create src/lib/plaid-sync.ts (SIMPLIFIED)
```typescript
import { getAccountBalances } from './plaid';
import { updateAsset } from './assets';
import { updateLiability } from './liabilities';
import { decryptToken } from './crypto';
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}
const prisma = globalForPrisma.prisma ?? new PrismaClient()
if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// Sync balances for all Plaid-connected assets/liabilities
export async function syncUserPlaidBalances(userId: string) {
  try {
    // Get all assets and liabilities that are Plaid-synced
    const [plaidAssets, plaidLiabilities] = await Promise.all([
      prisma.asset.findMany({
        where: { userId, isPlaidSynced: true, plaidAccessToken: { not: null } },
        select: {
          id: true,
          name: true,
          value: true,
          plaidAccountId: true,
          plaidAccessToken: true,
          plaidTokenIv: true,
        }
      }),
      prisma.liability.findMany({
        where: { userId, isPlaidSynced: true, plaidAccessToken: { not: null } },
        select: {
          id: true,
          name: true,
          value: true,
          plaidAccountId: true,
          plaidAccessToken: true,
          plaidTokenIv: true,
        }
      })
    ]);

    const syncResults = [];
    const allPlaidAccounts = [...plaidAssets, ...plaidLiabilities];

    for (const account of allPlaidAccounts) {
      try {
        // Decrypt access token for API call
        const decryptedToken = decryptToken(account.plaidAccessToken!, account.plaidTokenIv!);

        // Fetch fresh balance from Plaid
        const accounts = await getAccountBalances(decryptedToken);
        const accountData = accounts.find(acc => acc.account_id === account.plaidAccountId);

        if (!accountData?.balances.current) {
          console.warn(`No balance data for account ${account.plaidAccountId}`);
          continue;
        }

        const newValue = Math.abs(accountData.balances.current);
        const isAsset = plaidAssets.some(a => a.id === account.id);

        if (isAsset) {
          await updateAsset(account.id, {
            value: newValue,
            lastSyncedAt: new Date()
          });
        } else {
          await updateLiability(account.id, {
            value: newValue,
            lastSyncedAt: new Date()
          });
        }

        syncResults.push({
          id: account.id,
          name: account.name,
          type: isAsset ? 'asset' : 'liability',
          success: true,
          oldValue: Number(account.value),
          newValue,
        });

      } catch (accountError) {
        console.error(`Error syncing account ${account.id}:`, accountError);
        syncResults.push({
          id: account.id,
          name: account.name,
          success: false,
          error: accountError instanceof Error ? accountError.message : 'Unknown error',
        });
      }
    }

    return {
      success: true,
      results: syncResults,
      syncedAt: new Date(),
    };

  } catch (error) {
    console.error('Error syncing Plaid balances:', error);
    throw new Error('Failed to sync balances');
  }
}
```

Step 4.2: Add sync actions to src/app/actions.ts (SIMPLIFIED)
```typescript
import { syncUserPlaidBalances } from '@/lib/plaid-sync';

// Sync all Plaid balances
export async function syncPlaidBalancesAction() {
  try {
    const user = await getUser();
    if (!user) {
      return { success: false, error: 'Authentication required' };
    }

    const result = await syncUserPlaidBalances(user.id);
    return { success: true, data: result };
  } catch (error) {
    console.error('Error in sync action:', error);
    return { success: false, error: 'Unable to sync balances' };
  }
}
```

Step 4.3: Create sync button component
```typescript
'use client'

import { useState } from 'react';
import { Button } from './ui/button';
import { syncPlaidBalancesAction } from '@/app/actions';
import { useRouter } from 'next/navigation';
import { RefreshCw } from 'lucide-react';

export function PlaidSyncButton({ className }: { className?: string }) {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handleSync = async () => {
    setIsLoading(true);

    try {
      const result = await syncPlaidBalancesAction();

      if (result.success) {
        const { results } = result.data;
        const successCount = results.filter(r => r.success).length;
        alert(`Successfully synced ${successCount} account(s)!`);
        router.refresh();
      } else {
        alert(`Sync failed: ${result.error}`);
      }
    } catch (error) {
      alert('Failed to sync balances. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button
      onClick={handleSync}
      disabled={isLoading}
      variant="outline"
      size="sm"
      className={className}
    >
      <RefreshCw className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
      {isLoading ? 'Syncing...' : 'Refresh Balances'}
    </Button>
  );
}
```
```

üß† LEARNING NOTES:
- Sync function decrypts tokens only when needed for API calls
- Updates all connected assets/liabilities in one operation
- Simple error handling - just logs issues for personal use
- Supabase RLS ensures users can only sync their own accounts

üß† LEARNING NOTES:
- Access tokens are what you use for all API calls after initial connection
- Link tokens expire quickly (30 minutes) - they're just for the initial flow
- üîê CRITICAL: Access tokens are NOW encrypted before storage using AES-256
- üîê SECURITY: All database operations include authorization checks
- Sandbox environment lets you test without real bank accounts
- üîê SECURITY: All errors are sanitized before logging
- üîê SECURITY: Input validation is applied to all user inputs

‚ñ∂Ô∏è PHASE 3: ENHANCED ASSET/LIABILITY FORMS (Day 2-3 - 3-4 hours)
================================================================================

üéØ Goal: Add Plaid connection option to existing Asset and Liability forms

üìù WHAT WE'RE DOING:
Enhancing your existing AssetForm and LiabilityForm components to give users the choice:
"Enter value manually" OR "Link to your bank account"

üß† LEARNING FOCUS:
- Conditional form rendering
- State management for form modes
- Integrating third-party widgets into forms
- User experience for choice-driven workflows

‚úÖ TASKS:
1. Install Plaid Link SDK
2. Create PlaidLinkButton component
3. Enhance existing AssetForm with Plaid choice
4. Enhance existing LiabilityForm with Plaid choice
5. Handle both manual and Plaid creation flows

üìã DETAILED STEPS:

Step 3.1: Install Plaid Link for React
```bash
npm install react-plaid-link
npm install @types/react-plaid-link --save-dev
```

Step 3.2: Create src/lib/security.ts (NEW - Security Utilities)
```typescript
// üîê SECURITY: Rate limiting, CSP, and other security utilities

// Simple in-memory rate limiter (use Redis in production)
class RateLimiter {
  private requests = new Map<string, number[]>();

  async check(key: string, limit: number, windowMs: number): Promise<boolean> {
    const now = Date.now();
    const windowStart = now - windowMs;

    if (!this.requests.has(key)) {
      this.requests.set(key, []);
    }

    const userRequests = this.requests.get(key)!
      .filter(time => time > windowStart);

    if (userRequests.length >= limit) {
      return false;
    }

    userRequests.push(now);
    this.requests.set(key, userRequests);

    // Clean up old entries periodically
    if (Math.random() < 0.01) {
      this.cleanup(windowStart);
    }

    return true;
  }

  private cleanup(cutoff: number) {
    for (const [key, requests] of this.requests.entries()) {
      const validRequests = requests.filter(time => time > cutoff);
      if (validRequests.length === 0) {
        this.requests.delete(key);
      } else {
        this.requests.set(key, validRequests);
      }
    }
  }
}

export const rateLimit = new RateLimiter();

// üîê SECURITY: Content Security Policy headers
export const securityHeaders = {
  'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.plaid.com; connect-src 'self' https://production.plaid.com https://sandbox.plaid.com; img-src 'self' data: https:;",
  'X-Frame-Options': 'DENY',
  'X-Content-Type-Options': 'nosniff',
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'X-XSS-Protection': '1; mode=block',
};

// üîê SECURITY: Secure session configuration
export const sessionConfig = {
  cookieName: 'plaid-session',
  password: process.env.SESSION_SECRET || 'default-change-me-in-production',
  cookieOptions: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 1000 * 60 * 60 * 24, // 24 hours
    sameSite: 'strict' as const,
  },
};

// üîê SECURITY: Audit logging
export function auditLog(event: string, userId: string, details?: any) {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    userId: userId.substring(0, 8) + '...', // Partial ID for privacy
    details: details ? sanitizeForLogging(details) : undefined,
    ip: 'masked', // In production, you'd get this from request
  };

  console.log('AUDIT:', JSON.stringify(logEntry));

  // In production, send to secure logging service
  // await sendToSecureLogger(logEntry);
}

function sanitizeForLogging(obj: any): any {
  const sanitized = { ...obj };

  // Remove sensitive fields
  const sensitiveFields = ['accessToken', 'password', 'secret', 'key', 'token'];
  for (const field of sensitiveFields) {
    if (field in sanitized) {
      sanitized[field] = '[REDACTED]';
    }
  }

  return sanitized;
}
```

Step 3.3: Create src/components/PlaidLinkButton.tsx (SECURITY ENHANCED)
```typescript
'use client'

import { usePlaidLink } from 'react-plaid-link';
import { Button } from '@/components/ui/button';
import { useState } from 'react';
import { auditLog } from '@/lib/security';

interface PlaidLinkButtonProps {
  linkToken: string | null;
  onSuccess: (public_token: string, metadata: any) => void;
  onError?: (error: any) => void;
  buttonText?: string;
  className?: string;
  userId?: string; // üîê SECURITY: For audit logging
}

export function PlaidLinkButton({
  linkToken,
  onSuccess,
  onError,
  buttonText = "Link to Bank Account",
  className,
  userId
}: PlaidLinkButtonProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [attempts, setAttempts] = useState(0);

  // üîê SECURITY: Limit connection attempts
  const MAX_ATTEMPTS = 3;

  // üß† LEARNING: usePlaidLink hook handles the complex Plaid widget
  // üîê SECURITY: Enhanced with audit logging and attempt limiting
  const { open, ready } = usePlaidLink({
    token: linkToken,
    onSuccess: (public_token, metadata) => {
      setIsLoading(true);

      // üîê SECURITY: Audit successful connection
      if (userId) {
        auditLog('plaid_link_success', userId, {
          institution: metadata.institution?.name,
          accountCount: metadata.accounts?.length
        });
      }

      onSuccess(public_token, metadata);
    },
    onExit: (err, metadata) => {
      setIsLoading(false);

      if (err) {
        // üîê SECURITY: Audit failed attempts
        const newAttempts = attempts + 1;
        setAttempts(newAttempts);

        if (userId) {
          auditLog('plaid_link_error', userId, {
            error: err.error_code || 'unknown',
            attempts: newAttempts
          });
        }

        console.error('Plaid Link exit error:', err.error_code || err.error_message);
        onError?.(err);
      }
    },
    onEvent: (eventName, metadata) => {
      // üîê SECURITY: Log important events (but not sensitive data)
      if (['OPEN', 'EXIT', 'ERROR'].includes(eventName)) {
        console.log(`Plaid event: ${eventName}`);
      }
    },
  });

  const handleClick = () => {
    // üîê SECURITY: Check attempt limit
    if (attempts >= MAX_ATTEMPTS) {
      alert('Maximum connection attempts reached. Please refresh the page and try again.');
      return;
    }

    // üîê SECURITY: Audit connection attempt
    if (userId) {
      auditLog('plaid_link_attempt', userId);
    }

    open();
  };

  return (
    <Button
      type="button"
      onClick={handleClick}
      disabled={!ready || !linkToken || isLoading || attempts >= MAX_ATTEMPTS}
      variant="outline"
      className={className}
    >
      {isLoading ? 'Connecting...' :
       attempts >= MAX_ATTEMPTS ? 'Too Many Attempts' :
       buttonText}
    </Button>
  );
}
```

üß† WHY THIS PATTERN?
- The parent component provides the link token (keeps security logic higher up)
- onSuccess callback lets parent handle the result
- Disabled state prevents multiple clicks
- Loading state gives user feedback
- üîê SECURITY: Attempt limiting prevents abuse
- üîê SECURITY: Audit logging tracks all connection events
- üîê SECURITY: Sanitized error handling prevents information disclosure

Step 3.3: Create server action in src/app/actions.ts (add to existing file)
```typescript
// Add these imports to the top (SECURITY ENHANCED)
import { createLinkToken, exchangePublicToken, getAccounts } from '@/lib/plaid';
import { createPlaidAccount } from '@/lib/plaid-accounts';
import { sanitizeErrorMessage, UserIdSchema } from '@/lib/validation';
import { rateLimit } from '@/lib/security';

// üß† LEARNING: Server actions run on the server but can be called from client components
// üîê SECURITY: Enhanced with rate limiting and secure error handling
export async function createPlaidLinkTokenAction() {
  try {
    const user = await getUser();
    if (!user) {
      return { success: false, error: 'Authentication required' };
    }

    // üîê SECURITY: Rate limiting per user
    const canProceed = await rateLimit.check(user.id, 10, 60000); // 10 requests per minute
    if (!canProceed) {
      return { success: false, error: 'Too many requests. Please wait and try again.' };
    }

    // üîê SECURITY: Validate user ID
    const validatedUserId = UserIdSchema.parse(user.id);

    const linkToken = await createLinkToken(validatedUserId);
    return { success: true, linkToken };
  } catch (error) {
    console.error('Link token creation error:', sanitizeErrorMessage(error));
    return { success: false, error: 'Unable to create connection. Please try again.' };
  }
}

export async function exchangePlaidTokenAction(publicToken: string, metadata: any) {
  try {
    const user = await getUser();
    if (!user) {
      return { success: false, error: 'Authentication required' };
    }

    // üîê SECURITY: Rate limiting for token exchange
    const canProceed = await rateLimit.check(`exchange_${user.id}`, 5, 300000); // 5 exchanges per 5 minutes
    if (!canProceed) {
      return { success: false, error: 'Too many connection attempts. Please wait.' };
    }

    // üîê SECURITY: Validate inputs
    const validatedUserId = UserIdSchema.parse(user.id);
    if (!publicToken || typeof publicToken !== 'string') {
      return { success: false, error: 'Invalid connection data' };
    }

    // üß† LEARNING: This is the key exchange - public token for access token
    const { accessToken, itemId } = await exchangePublicToken(publicToken);

    // Get account details from Plaid
    const accountsData = await getAccounts(accessToken);

    // üîê SECURITY: Limit number of accounts per user
    const existingAccountCount = await getUserPlaidAccounts(validatedUserId);
    if (existingAccountCount.length + accountsData.accounts.length > 10) {
      return { success: false, error: 'Maximum number of connected accounts reached' };
    }

    // Create database records for each account
    const createdAccounts = [];
    for (const account of accountsData.accounts) {
      const plaidAccount = await createPlaidAccount(validatedUserId, {
        plaidAccountId: account.account_id,
        accessToken, // üîê NOW ENCRYPTED before storage!
        institutionId: accountsData.item.institution_id || '',
        institutionName: metadata.institution?.name || 'Unknown Bank',
        accountName: account.name,
        accountType: account.type,
        accountSubtype: account.subtype || undefined,
        mask: account.mask || undefined,
      });
      createdAccounts.push(plaidAccount);
    }

    return { success: true, accounts: createdAccounts };
  } catch (error) {
    console.error('Token exchange error:', sanitizeErrorMessage(error));
    return { success: false, error: 'Unable to connect account. Please try again.' };
  }
}
```

Step 3.4: Enhance src/components/AssetForm.tsx (SECURITY ENHANCED)
```typescript
// Add these imports (SECURITY ENHANCED)
import { useState, useEffect } from 'react';
import { PlaidLinkButton } from './PlaidLinkButton';
import { createPlaidLinkTokenAction } from '@/app/actions';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import { AssetFormSchema } from '@/lib/validation';
import { auditLog } from '@/lib/security';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// Add to your existing AssetForm component (SECURITY ENHANCED):
interface AssetFormProps {
  onSubmit: (data: any) => void;
  onCancel: () => void;
  userId?: string; // üîê SECURITY: For audit logging
}

export function AssetForm({ onSubmit, onCancel, userId }: AssetFormProps) {
  const [entryMode, setEntryMode] = useState<'manual' | 'plaid'>('manual');
  const [linkToken, setLinkToken] = useState<string | null>(null);
  const [plaidData, setPlaidData] = useState<any>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // üîê SECURITY: Form validation with Zod schema
  const { register, handleSubmit, setValue, formState: { errors }, reset } = useForm({
    resolver: zodResolver(AssetFormSchema),
    defaultValues: {
      name: '',
      category: '',
      value: 0,
      description: ''
    }
  });

  // Initialize link token when component mounts (SECURITY ENHANCED)
  useEffect(() => {
    async function initializeLinkToken() {
      if (entryMode === 'plaid' && !linkToken) {
        try {
          const result = await createPlaidLinkTokenAction();
          if (result.success) {
            setLinkToken(result.linkToken);
            // üîê SECURITY: Audit token creation
            if (userId) {
              auditLog('link_token_created', userId);
            }
          } else {
            console.error('Failed to create link token:', result.error);
          }
        } catch (error) {
          console.error('Link token initialization failed:', error);
        }
      }
    }
    initializeLinkToken();
  }, [entryMode, linkToken, userId]);

  const handlePlaidSuccess = (publicToken: string, metadata: any) => {
    try {
      // üîê SECURITY: Validate Plaid response data
      if (!publicToken || !metadata?.institution?.name) {
        throw new Error('Invalid Plaid connection data');
      }

      // Store Plaid data for form submission
      setPlaidData({ publicToken, metadata });

      // üîê SECURITY: Sanitize and validate auto-filled data
      const institutionName = metadata.institution.name.substring(0, 50);
      const accountName = metadata.accounts?.[0]?.name?.substring(0, 50) || 'Account';

      setValue('name', `${institutionName} ${accountName}`);
      setValue('value', 0); // Will be synced after connection
      setValue('description', `Auto-synced from ${institutionName}`);

      // üîê SECURITY: Audit successful connection
      if (userId) {
        auditLog('plaid_form_connected', userId, {
          institution: institutionName,
          accountCount: metadata.accounts?.length || 0
        });
      }
    } catch (error) {
      console.error('Error processing Plaid connection:', error);
      alert('Connection successful, but there was an error processing the data. Please try again.');
      setPlaidData(null);
    }
  };

  const handleFormSubmit = async (data: any) => {
    if (isSubmitting) return;

    setIsSubmitting(true);
    try {
      // üîê SECURITY: Additional validation before submission
      const validatedData = AssetFormSchema.parse(data);

      // üîê SECURITY: Audit form submission
      if (userId) {
        auditLog('asset_form_submit', userId, {
          type: entryMode,
          hasPlaidData: !!plaidData,
          category: validatedData.category
        });
      }

      await onSubmit({ ...validatedData, plaidData });
    } catch (error) {
      console.error('Form submission error:', error);
      alert('There was an error submitting the form. Please check your inputs and try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit(handleFormSubmit)}>
      {/* Choice between manual and Plaid */}
      <div className="mb-6">
        <Label className="text-base font-medium">How would you like to track this asset?</Label>
        <RadioGroup value={entryMode} onValueChange={(value) => setEntryMode(value as 'manual' | 'plaid')} className="mt-2">
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="manual" id="manual" />
            <Label htmlFor="manual">Enter value manually</Label>
          </div>
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="plaid" id="plaid" />
            <Label htmlFor="plaid">Link to bank account (auto-sync)</Label>
          </div>
        </RadioGroup>
      </div>

      {/* Existing form fields */}
      <div className="space-y-4">
        <div>
          <Label htmlFor="name">Asset Name</Label>
          <Input
            id="name"
            {...register('name', { required: 'Asset name is required' })}
          />
          {errors.name && <p className="text-red-500 text-sm">{errors.name.message}</p>}
        </div>

        {/* Conditional value input vs Plaid button */}
        {entryMode === 'manual' ? (
          <div>
            <Label htmlFor="value">Value</Label>
            <Input
              id="value"
              type="number"
              step="0.01"
              min="0"
              max="999999999999.99"
              {...register('value', {
                required: 'Value is required',
                valueAsNumber: true,
                validate: (value) => {
                  if (value < 0) return 'Value must be positive';
                  if (value > 999999999999.99) return 'Value too large';
                  return true;
                }
              })}
            />
            {errors.value && <p className="text-red-500 text-sm">{errors.value.message}</p>}
          </div>
        ) : (
          <div>
            <Label>Bank Account Connection</Label>
            {plaidData ? (
              <div className="p-3 bg-green-50 border border-green-200 rounded">
                <p className="text-green-700">‚úÖ Connected to {plaidData.metadata.institution.name}</p>
                <p className="text-sm text-green-600">Balance will be automatically synced</p>
              </div>
            ) : (
              <PlaidLinkButton
                linkToken={linkToken}
                onSuccess={handlePlaidSuccess}
                onError={(error) => {
                  console.error('Plaid connection error:', error);
                  alert('Unable to connect to your bank. Please try again or contact support.');
                }}
                buttonText="Connect to Bank Account"
                className="w-full"
                userId={userId}
              />
            )}
          </div>
        )}

        {/* Rest of your existing form fields */}
      </div>

      {/* Submit button */}
      <div className="flex gap-2 mt-6">
        <Button
          type="submit"
          disabled={isSubmitting || (entryMode === 'plaid' && !plaidData)}
          className="min-w-[120px]"
        >
          {isSubmitting ? 'Creating...' :
           entryMode === 'plaid' && !plaidData ? 'Connect Account First' :
           'Create Asset'}
        </Button>
        <Button
          type="button"
          variant="outline"
          onClick={onCancel}
          disabled={isSubmitting}
        >
          Cancel
        </Button>
      </div>
    </form>
  );
}
```

üß† LEARNING NOTES:
- Server actions bridge client and server securely
- router.refresh() re-runs server components (updates the page with new data)
- Always handle errors gracefully - banks can be finicky!
- Link tokens expire, so we create them fresh each time

‚ñ∂Ô∏è PHASE 4: PLAID SYNC INTEGRATION (Day 3-4 - 2-3 hours)
================================================================================

üéØ Goal: Handle Plaid account creation and automatic balance syncing

üìù WHAT WE'RE DOING:
Building server actions to process Plaid connections from forms and sync balances
for assets/liabilities that users chose to link to their bank accounts.

üß† LEARNING FOCUS:
- Processing Plaid tokens from form submissions
- Creating assets/liabilities with Plaid data
- Automatic balance syncing for connected accounts
- Handling mixed manual and Plaid entries

‚úÖ TASKS:
1. Create server actions for Plaid-connected asset/liability creation
2. Build balance syncing functions
3. Add "Refresh Balances" functionality for connected accounts
4. Update existing CRUD operations to handle Plaid fields

üìã DETAILED STEPS:

Step 4.1: Create src/lib/plaid-sync.ts
```typescript
import { getAccountBalances } from './plaid';
import { updateAsset } from './assets';
import { updateLiability } from './liabilities';
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}
const prisma = globalForPrisma.prisma ?? new PrismaClient()
if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// üß† LEARNING: Sync balances for all Plaid-connected assets/liabilities
export async function syncUserPlaidBalances(userId: string) {
  try {
    // Get all assets and liabilities that are Plaid-synced
    const [plaidAssets, plaidLiabilities] = await Promise.all([
      prisma.asset.findMany({
        where: { userId, isPlaidSynced: true, plaidAccessToken: { not: null } }
      }),
      prisma.liability.findMany({
        where: { userId, isPlaidSynced: true, plaidAccessToken: { not: null } }
      })
    ]);

    const syncResults = [];
    const allPlaidAccounts = [...plaidAssets, ...plaidLiabilities];

    for (const account of allPlaidAccounts) {
      try {
        // Fetch fresh balance from Plaid
        const accounts = await getAccountBalances(account.plaidAccessToken!);
        const accountData = accounts.find(acc => acc.account_id === account.plaidAccountId);

        if (!accountData?.balances.current) {
          console.warn(`No balance data for account ${account.plaidAccountId}`);
          continue;
        }

        const newValue = Math.abs(accountData.balances.current); // Use absolute value
        const isAsset = 'assets' in prisma && await prisma.asset.findUnique({ where: { id: account.id } });

        if (isAsset) {
          await updateAsset(account.id, {
            value: newValue,
            lastSyncedAt: new Date()
          });
        } else {
          await updateLiability(account.id, {
            value: newValue,
            lastSyncedAt: new Date()
          });
        }

        syncResults.push({
          id: account.id,
          name: account.name,
          type: isAsset ? 'asset' : 'liability',
          success: true,
          oldValue: Number(account.value),
          newValue,
        });

      } catch (accountError) {
        console.error(`Error syncing account ${account.id}:`, accountError);
        syncResults.push({
          id: account.id,
          name: account.name,
          success: false,
          error: accountError.message,
        });
      }
    }

    return {
      success: true,
      results: syncResults,
      syncedAt: new Date(),
    };

  } catch (error) {
    console.error('Error syncing Plaid balances:', error);
    throw new Error('Failed to sync balances');
  }
}

// üß† LEARNING: Helper function to categorize accounts
export function getAssetCategory(accountType: string): string {
  switch (accountType) {
    case 'depository':
      return 'Cash';
    case 'investment':
    case 'brokerage':
      return 'Investments';
    default:
      return 'Other';
  }
}

export function getLiabilityCategory(accountType: string): string {
  switch (accountType) {
    case 'credit':
      return 'Credit Card';
    case 'loan':
      return 'Loan';
    case 'mortgage':
      return 'Mortgage';
    default:
      return 'Other';
  }
}

// Sync a single account (asset or liability)
export async function syncSingleAccount(accountId: string, type: 'asset' | 'liability') {
  try {
    const account = type === 'asset'
      ? await prisma.asset.findUnique({ where: { id: accountId } })
      : await prisma.liability.findUnique({ where: { id: accountId } });

    if (!account || !account.isPlaidSynced || !account.plaidAccessToken) {
      throw new Error('Account not found or not Plaid-synced');
    }

    const accounts = await getAccountBalances(account.plaidAccessToken);
    const accountData = accounts.find(acc => acc.account_id === account.plaidAccountId);

    if (!accountData?.balances.current) {
      throw new Error('No balance data available');
    }

    const newValue = Math.abs(accountData.balances.current);

    if (type === 'asset') {
      await updateAsset(accountId, { value: newValue, lastSyncedAt: new Date() });
    } else {
      await updateLiability(accountId, { value: newValue, lastSyncedAt: new Date() });
    }

    return {
      success: true,
      newBalance: newValue,
      syncedAt: new Date(),
    };

  } catch (error) {
    console.error('Error syncing single account:', error);
    throw error;
  }
}
```






```



================================================================================

üéØ Goal: Update dashboard and lists to show sync status for connected accounts

üìù WHAT WE'RE DOING:
Enhancing your existing AssetsList and LiabilitiesList components to show which
accounts are manually entered vs auto-synced from bank accounts.

üß† LEARNING FOCUS:
- Conditional rendering for different data sources
- Visual indicators for sync status
- Unified UI that handles both manual and Plaid entries
- User feedback for sync operations

‚úÖ TASKS:
1. Add sync status indicators to existing asset/liability lists
2. Show last sync timestamps for connected accounts
3. Add "Refresh Balances" functionality
4. Update dashboard totals to include both manual and synced values

üìã DETAILED STEPS:

Step 5.1: Enhance src/components/AssetsList.tsx (example enhancement)
```typescript
// Add these imports to your existing AssetsList
import { Badge } from './ui/badge';
import { Button } from './ui/button';
import { RefreshCw, Link2, Edit3 } from 'lucide-react';
import { syncSingleAccount } from '@/lib/plaid-sync';
import { useState } from 'react';

// Enhance your existing AssetsList component:
export function AssetsList({ assets, onEdit, onDelete }: AssetsListProps) {
  const [syncing, setSyncing] = useState<string | null>(null);

  const handleSyncSingle = async (assetId: string) => {
    setSyncing(assetId);
    try {
      await syncSingleAccount(assetId, 'asset');
      // Refresh the page or update local state
      window.location.reload(); // Simple approach
    } catch (error) {
      console.error('Sync failed:', error);
      alert('Failed to sync balance. Please try again.');
    } finally {
      setSyncing(null);
    }
  };

  return (
    <div className="space-y-3">
      {assets.map((asset) => (
        <div key={asset.id} className="flex items-center justify-between p-4 border rounded-lg">
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-1">
              <h3 className="font-medium">{asset.name}</h3>

              {/* NEW: Sync status badges */}
              {asset.isPlaidSynced ? (
                <Badge variant="secondary" className="text-xs bg-blue-50 text-blue-700">
                  <Link2 className="w-3 h-3 mr-1" />
                  {asset.institutionName}
                </Badge>
              ) : (
                <Badge variant="outline" className="text-xs">
                  <Edit3 className="w-3 h-3 mr-1" />
                  Manual
                </Badge>
              )}
            </div>

            <p className="text-sm text-muted-foreground">
              {asset.category} ‚Ä¢ {formatCurrency(Number(asset.value))}
            </p>

            {/* NEW: Show last sync time for Plaid accounts */}
            {asset.isPlaidSynced && asset.lastSyncedAt && (
              <p className="text-xs text-muted-foreground mt-1">
                Last synced: {new Date(asset.lastSyncedAt).toLocaleString()}
              </p>
            )}

            {asset.description && (
              <p className="text-xs text-muted-foreground mt-1">{asset.description}</p>
            )}
          </div>

          <div className="flex items-center gap-2">
            {/* NEW: Sync button for Plaid accounts */}
            {asset.isPlaidSynced && (
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleSyncSingle(asset.id)}
                disabled={syncing === asset.id}
                className="h-8 w-8 p-0"
              >
                <RefreshCw className={`w-4 h-4 ${syncing === asset.id ? 'animate-spin' : ''}`} />
              </Button>
            )}

            {/* Existing edit/delete buttons - only show for manual entries */}
            {!asset.isPlaidSynced && (
              <>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => onEdit(asset)}
                  className="h-8 w-8 p-0"
                >
                  <Edit3 className="w-4 h-4" />
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => onDelete(asset.id)}
                  className="h-8 w-8 p-0 text-destructive hover:text-destructive"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
```

Step 5.2: Update src/app/page.tsx (minimal changes needed)
```typescript
// Add just the sync button import
import { PlaidSyncButton } from '@/components/PlaidSyncButton';

// Your existing page component stays mostly the same
export default async function Home() {
  const user = await getUser();
  if (!user) redirect("/auth");

  // Existing data fetching (no changes needed)
  const [assets, liabilities] = await Promise.all([
    getUserAssetsAction(),
    getUserLiabilitiesAction()
  ]);

  // Calculate totals (includes both manual and Plaid-synced assets/liabilities)
  const totalAssets = calculateTotalAssets(assets);
  const totalLiabilities = calculateTotalLiabilities(liabilities);
  const netWorth = calculateNetWorth(totalAssets, totalLiabilities);

  return (
    <div className="min-h-screen p-6 lg:p-8">
      <div className="max-w-7xl mx-auto">
        {/* Header section - just add sync button */}
        <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-10">
          <div className="mb-4 sm:mb-0">
            <h1 className="heading-xl bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
              Net Worth Tracker
            </h1>
            <p className="text-muted-foreground mt-2">
              Track your financial progress and build wealth
            </p>
          </div>
          <div className="flex items-center gap-4">
            {/* NEW: Add sync button for Plaid accounts */}
            <PlaidSyncButton />
            <div className="text-right hidden sm:block">
              <p className="text-sm text-muted-foreground">Welcome back</p>
              <p className="font-medium">{user.email}</p>
            </div>
            <form action={signOut}>
              <Button variant="outline" type="submit" className="btn-financial">
                Sign Out
              </Button>
            </form>
          </div>
        </div>

        {/* Summary cards (no changes - totals automatically include Plaid accounts) */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-10 animate-fade-in">
          {/* Your existing summary cards work perfectly */}
        </div>

        {/* Your existing DashboardClient - enhanced lists will show sync status */}
        <DashboardClient initialAssets={assets} initialLiabilities={liabilities} />
      </div>
    </div>
  );
}
```

Step 5.3: Create src/components/PlaidSyncButton.tsx (global sync button)
```typescript
'use client'

import { useState } from 'react';
import { Button } from './ui/button';
import { syncPlaidBalancesAction } from '@/app/actions';
import { useRouter } from 'next/navigation';
import { RefreshCw } from 'lucide-react';

interface PlaidSyncButtonProps {
  className?: string;
}

export function PlaidSyncButton({ className }: PlaidSyncButtonProps) {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handleSyncAll = async () => {
    setIsLoading(true);

    try {
      const result = await syncPlaidBalancesAction();

      if (result.success) {
        const { results } = result.data;
        const successCount = results.filter(r => r.success).length;
        const totalCount = results.length;

        if (totalCount === 0) {
          alert('No connected accounts to sync.');
        } else {
          alert(`Synced ${successCount} of ${totalCount} connected account(s)!`);
        }

        // Refresh to show updated balances
        router.refresh();
      } else {
        alert(`Sync failed: ${result.error}`);
      }
    } catch (error) {
      console.error('Sync error:', error);
      alert('Failed to sync balances. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button
      onClick={handleSyncAll}
      disabled={isLoading}
      variant="outline"
      size="sm"
      className={className}
    >
      <RefreshCw className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
      {isLoading ? 'Syncing...' : 'Refresh Connected Balances'}
    </Button>
  );
}
```

üß† LEARNING NOTES:
- All assets/liabilities show in same lists with clear visual indicators
- Manual entries can be edited/deleted, Plaid entries can only be synced
- Sync timestamps show when bank data was last refreshed
- Users get both individual sync (per account) and bulk sync (all accounts)
- Totals automatically include both manual and Plaid-synced values

================================================================================
5. TROUBLESHOOTING & COMMON ISSUES (SIMPLIFIED)
================================================================================

üêõ COMMON PROBLEMS & SOLUTIONS:

Problem: "Invalid credentials" error
Solution: Double-check your PLAID_CLIENT_ID and PLAID_SECRET in .env

Problem: Link token expires
Solution: Link tokens are short-lived (30 min). Generate fresh ones.

Problem: Access token becomes invalid
Solution: Banks can revoke access. Handle this gracefully and prompt re-connection.

Problem: Balance shows as null
Solution: Not all banks provide all balance types. Check for null values.

Problem: Migration fails
Solution: Check your schema syntax and ensure Prisma CLI is updated.

Problem: "Module not found" errors
Solution: Restart your dev server after installing new packages.

Problem: "Failed to encrypt token" error
Solution: Check PLAID_ENCRYPTION_KEY is 64 characters (32 bytes hex)

üîç DEBUGGING TIPS:
1. Check browser console for client-side errors
2. Check server logs for API errors
3. Use Plaid's dashboard to monitor API calls
4. Test with Plaid's sandbox accounts first

================================================================================
6. RESOURCES & DOCUMENTATION
================================================================================

üìö ESSENTIAL READING:
- Plaid Quickstart: https://plaid.com/docs/quickstart/
- Plaid Link Guide: https://plaid.com/docs/link/
- Balance API Reference: https://plaid.com/docs/api/products/balance/
- React Plaid Link: https://github.com/plaid/react-plaid-link

üõ†Ô∏è TOOLS:
- Plaid Dashboard: https://dashboard.plaid.com/
- Plaid Postman Collection: Test APIs manually
- Plaid Support: help@plaid.com

üè¶ SANDBOX TEST ACCOUNTS:
Username: user_good
Password: pass_good
(This gives you fake accounts to test with)

================================================================================
PHASE SUMMARY & NEXT STEPS (SIMPLIFIED)
================================================================================

‚úÖ AFTER PHASE 5, YOU'LL HAVE:
- User choice workflow: Manual OR Plaid linking per asset/liability
- Enhanced Asset/Liability forms with Plaid connection option
- Real-time balance syncing for connected accounts
- Dashboard showing all accounts with clear sync indicators
- Bulk sync functionality with simple refresh button
- Basic error handling and user feedback
- **Token encryption** for secure storage (recommended by Plaid)
- **Simple validation** to prevent app crashes
- **Supabase RLS** handling user data separation

üöÄ FUTURE ENHANCEMENTS:
- Automatic scheduled syncing (background jobs)
- Transaction history import
- Account disconnection flows
- Better error recovery with retry logic
- Mobile-responsive improvements

üéì SKILLS YOU'VE LEARNED:
- Third-party API integration (Plaid)
- OAuth-like token flows (Link ‚Üí Public ‚Üí Access tokens)
- Database schema evolution with optional fields
- Conditional form rendering for user choices
- React component enhancement patterns
- State management for mixed data sources
- Basic error handling for external APIs
- Simple token encryption for security
- User experience design for choice-driven workflows

üìù **PERSONAL APP NOTES**:
This simplified implementation is perfect for personal use by you and your wife. It includes the essential security measures (token encryption) while keeping complexity manageable. Supabase handles user authentication and data separation automatically.

Remember: Start with Phase 1 and test each phase thoroughly before moving on!