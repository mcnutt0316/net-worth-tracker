# PLAID INTEGRATION PLAN FOR NET WORTH TRACKER
# A Complete Guide for Junior Engineers

================================================================================
TABLE OF CONTENTS
================================================================================
1. OVERVIEW & LEARNING OBJECTIVES
2. UNDERSTANDING PLAID (What is it? How does it work?)
3. PROJECT ARCHITECTURE DECISIONS
4. PHASE-BY-PHASE IMPLEMENTATION PLAN
5. TROUBLESHOOTING & COMMON ISSUES
6. RESOURCES & DOCUMENTATION

================================================================================
1. OVERVIEW & LEARNING OBJECTIVES
================================================================================

üéØ GOAL: Give users the choice to either manually enter asset/liability values OR connect them to their bank accounts via Plaid for automatic syncing

üß† WHAT YOU'LL LEARN:
- How financial APIs work (Plaid specifically)
- OAuth-like flows (Link token ‚Üí Public token ‚Üí Access token)
- Database schema design for third-party integrations
- React component patterns for external widgets
- Error handling for external services
- Token management and security best practices

üí° WHY PLAID?
- Connects to 11,000+ financial institutions
- Handles authentication securely (you never see passwords)
- Provides real-time balance data
- Industry standard for fintech apps

================================================================================
2. UNDERSTANDING PLAID (What is it? How does it work?)
================================================================================

üîç PLAID BASICS:
Plaid is a "financial data network" - think of it as a secure bridge between your app and banks.

üìä THE FLOW:
1. User clicks "Connect Bank Account" in your app
2. Plaid Link widget opens (hosted by Plaid)
3. User enters their bank credentials (Plaid sees this, not you)
4. Bank authenticates user
5. Plaid returns a "public_token" to your app
6. Your backend exchanges public_token for "access_token"
7. You store access_token securely
8. Use access_token to fetch balances anytime

üîê SECURITY NOTES:
- You never see user bank passwords
- Access tokens are encrypted and stored securely
- Plaid is bank-grade security (SOC 2, ISO 27001)
- Tokens can be revoked by user anytime

================================================================================
3. PROJECT ARCHITECTURE DECISIONS
================================================================================

üèóÔ∏è HOW WE'LL STRUCTURE THIS:

CURRENT STATE:
- Manual asset/liability tracking
- Static values entered by user
- Simple CRUD operations

TARGET STATE:
- User choice workflow: Manual entry OR Plaid linking per asset/liability
- Seamless integration within existing forms
- Real-time balance updates for connected accounts
- Clear visual indicators showing sync status

üóÑÔ∏è DATABASE CHANGES:
We'll enhance your existing Asset and Liability tables with optional Plaid fields.
No separate tables needed - everything stays unified with optional bank linking.

üìÅ FILE STRUCTURE:
src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ plaid.ts (‚úÖ exists, needs enhancement)
‚îÇ   ‚îú‚îÄ‚îÄ plaid-sync.ts (new - balance syncing logic)
‚îÇ   ‚îú‚îÄ‚îÄ assets.ts (enhance with Plaid functions)
‚îÇ   ‚îî‚îÄ‚îÄ liabilities.ts (enhance with Plaid functions)
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ PlaidLinkButton.tsx (new - embedded in forms)
‚îÇ   ‚îú‚îÄ‚îÄ AssetForm.tsx (enhance with Plaid choice)
‚îÇ   ‚îî‚îÄ‚îÄ LiabilityForm.tsx (enhance with Plaid choice)
‚îî‚îÄ‚îÄ app/
    ‚îî‚îÄ‚îÄ actions.ts (enhance with Plaid actions)

================================================================================
4. PHASE-BY-PHASE IMPLEMENTATION PLAN
================================================================================

‚ñ∂Ô∏è PHASE 1: DATABASE FOUNDATION (Day 1 - 1-2 hours)
================================================================================

üéØ Goal: Enhance existing Asset/Liability tables to support optional Plaid linking

üìù WHAT WE'RE DOING:
Adding Plaid-related fields to your existing Asset and Liability models.
This keeps everything unified while adding optional bank account syncing.

üß† LEARNING FOCUS:
- Database schema evolution
- Optional fields and nullable columns
- Backwards compatibility in migrations

‚úÖ TASKS:
1. Add Plaid fields to existing Asset and Liability models
2. Run migration
3. Update TypeScript types
4. Test existing functionality still works

üìã DETAILED STEPS:

Step 1.1: Update prisma/schema.prisma
```prisma
// Enhance existing Asset model with optional Plaid fields
model Asset {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name             String
  category         String
  value            Decimal  @db.Decimal(15, 2)
  description      String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  userId           String   @db.Uuid

  // NEW: Optional Plaid integration fields
  plaidAccountId   String?                     // Plaid's account ID (if linked)
  plaidAccessToken String?                     // Access token (encrypted in production)
  institutionName  String?                     // Bank name (e.g., "Chase")
  isPlaidSynced    Boolean  @default(false)    // Is this auto-synced from bank?
  lastSyncedAt     DateTime?                   // When was balance last updated?

  @@map("assets")
}

// Enhance existing Liability model with optional Plaid fields
model Liability {
  id               String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name             String
  category         String
  value            Decimal  @db.Decimal(15, 2)
  description      String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  userId           String   @db.Uuid

  // NEW: Optional Plaid integration fields
  plaidAccountId   String?                     // Plaid's account ID (if linked)
  plaidAccessToken String?                     // Access token (encrypted in production)
  institutionName  String?                     // Bank name (e.g., "Chase")
  isPlaidSynced    Boolean  @default(false)    // Is this auto-synced from bank?
  lastSyncedAt     DateTime?                   // When was balance last updated?

  @@map("liabilities")
}
```

üß† WHY THIS DESIGN?
- No separate tables - everything stays unified in existing Asset/Liability models
- Optional Plaid fields mean existing manual entries are unaffected
- Each asset/liability can be either manual OR Plaid-synced individually
- Boolean flags make it easy to distinguish and handle different types
- Simple migration that doesn't break existing data

Step 1.2: Create and run migration
```bash
npx prisma migrate dev --name add_plaid_fields_to_assets_liabilities
```

Step 1.3: Update TypeScript types in src/lib/assets.ts
```typescript
// Enhanced types for assets with optional Plaid integration
export type CreateAssetData = {
  name: string
  category: string
  value: number
  description?: string
  // NEW: Optional Plaid fields
  plaidAccountId?: string
  plaidAccessToken?: string
  institutionName?: string
  isPlaidSynced?: boolean
}

export type UpdateAssetData = {
  name?: string
  category?: string
  value?: number
  description?: string
  // NEW: Optional Plaid fields for updates
  plaidAccountId?: string
  plaidAccessToken?: string
  institutionName?: string
  isPlaidSynced?: boolean
  lastSyncedAt?: Date
}
```

üö® GOTCHAS TO WATCH FOR:
- Make sure your DATABASE_URL is set correctly
- If migration fails, check for syntax errors in schema
- Remember to restart your dev server after schema changes

‚ñ∂Ô∏è PHASE 2: PLAID CLIENT ENHANCEMENT (Day 1-2 - 2-3 hours)
================================================================================

üéØ Goal: Build robust Plaid integration functions

üìù WHAT WE'RE DOING:
Enhancing your existing Plaid client with functions to handle the complete flow.

üß† LEARNING FOCUS:
- API client patterns
- Token exchange flows
- Error handling strategies
- Environment configuration

‚úÖ TASKS:
1. Enhance src/lib/plaid.ts with new functions
2. Create src/lib/plaid-accounts.ts for database operations
3. Add environment variables
4. Test basic connectivity

üìã DETAILED STEPS:

Step 2.1: Enhance src/lib/plaid.ts
```typescript
import {
  Configuration,
  PlaidApi,
  PlaidEnvironments,
  LinkTokenCreateRequest,
  ItemPublicTokenExchangeRequest,
  AccountsBalanceGetRequest,
  CountryCode,
  Products
} from 'plaid';

const config = new Configuration({
  basePath: PlaidEnvironments[process.env.PLAID_ENV as keyof typeof PlaidEnvironments] || PlaidEnvironments.sandbox,
  baseOptions: {
    headers: {
      'PLAID-CLIENT-ID': process.env.PLAID_CLIENT_ID!,
      'PLAID-SECRET': process.env.PLAID_SECRET!,
    },
  },
});

export const plaidClient = new PlaidApi(config);

// üß† LEARNING: Link tokens are short-lived tokens that initialize Plaid Link
export async function createLinkToken(userId: string) {
  try {
    const request: LinkTokenCreateRequest = {
      user: {
        client_user_id: userId, // Your user's ID
      },
      client_name: 'Net Worth Tracker',
      products: [Products.Transactions], // What Plaid products you want
      country_codes: [CountryCode.Us],
      language: 'en',
    };

    const response = await plaidClient.linkTokenCreate(request);
    return response.data.link_token;
  } catch (error) {
    console.error('Error creating link token:', error);
    throw new Error('Failed to create link token');
  }
}

// üß† LEARNING: Exchange public token (from Link) for access token (permanent)
export async function exchangePublicToken(publicToken: string) {
  try {
    const request: ItemPublicTokenExchangeRequest = {
      public_token: publicToken,
    };

    const response = await plaidClient.itemPublicTokenExchange(request);
    return {
      accessToken: response.data.access_token,
      itemId: response.data.item_id,
    };
  } catch (error) {
    console.error('Error exchanging public token:', error);
    throw new Error('Failed to exchange public token');
  }
}

// üß† LEARNING: This fetches real-time balances from the bank
export async function getAccountBalances(accessToken: string) {
  try {
    const request: AccountsBalanceGetRequest = {
      access_token: accessToken,
    };

    const response = await plaidClient.accountsBalanceGet(request);
    return response.data.accounts;
  } catch (error) {
    console.error('Error fetching account balances:', error);
    throw new Error('Failed to fetch account balances');
  }
}

// üß† LEARNING: Get account details (institution info, account names, etc.)
export async function getAccounts(accessToken: string) {
  try {
    const request = {
      access_token: accessToken,
    };

    const response = await plaidClient.accountsGet(request);
    return response.data;
  } catch (error) {
    console.error('Error fetching accounts:', error);
    throw new Error('Failed to fetch accounts');
  }
}
```

Step 2.2: Create src/lib/plaid-accounts.ts
```typescript
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

export type CreatePlaidAccountData = {
  plaidAccountId: string
  accessToken: string
  institutionId: string
  institutionName: string
  accountName: string
  accountType: string
  accountSubtype?: string
  mask?: string
}

// üß† LEARNING: This saves a connected Plaid account to our database
export async function createPlaidAccount(userId: string, accountData: CreatePlaidAccountData) {
  try {
    const plaidAccount = await prisma.plaidAccount.create({
      data: {
        ...accountData,
        userId,
        lastSyncedAt: new Date(), // Mark as synced now
      }
    });
    return plaidAccount;
  } catch (error) {
    console.error('Error creating Plaid account:', error);
    throw new Error('Failed to create Plaid account');
  }
}

// Get all Plaid accounts for a user
export async function getUserPlaidAccounts(userId: string) {
  try {
    return await prisma.plaidAccount.findMany({
      where: { userId, isActive: true },
      include: {
        assets: true, // Include linked assets
      },
      orderBy: { createdAt: 'desc' }
    });
  } catch (error) {
    console.error('Error fetching Plaid accounts:', error);
    throw new Error('Failed to fetch Plaid accounts');
  }
}

// üß† LEARNING: This updates an asset's value with fresh data from Plaid
export async function updateAssetFromPlaid(assetId: string, newValue: number) {
  try {
    return await prisma.asset.update({
      where: { id: assetId },
      data: {
        value: newValue,
        lastSyncedAt: new Date(),
      }
    });
  } catch (error) {
    console.error('Error updating asset from Plaid:', error);
    throw new Error('Failed to update asset');
  }
}
```

Step 2.3: Update .env file
```env
# Add these Plaid variables (you'll get these from Plaid Dashboard)
PLAID_CLIENT_ID=your_client_id_here
PLAID_SECRET=your_secret_here
PLAID_ENV=sandbox
```

üß† LEARNING NOTES:
- Access tokens are what you use for all API calls after initial connection
- Link tokens expire quickly (30 minutes) - they're just for the initial flow
- Always encrypt access tokens in production (we'll use basic storage for now)
- Sandbox environment lets you test without real bank accounts

‚ñ∂Ô∏è PHASE 3: ENHANCED ASSET/LIABILITY FORMS (Day 2-3 - 3-4 hours)
================================================================================

üéØ Goal: Add Plaid connection option to existing Asset and Liability forms

üìù WHAT WE'RE DOING:
Enhancing your existing AssetForm and LiabilityForm components to give users the choice:
"Enter value manually" OR "Link to your bank account"

üß† LEARNING FOCUS:
- Conditional form rendering
- State management for form modes
- Integrating third-party widgets into forms
- User experience for choice-driven workflows

‚úÖ TASKS:
1. Install Plaid Link SDK
2. Create PlaidLinkButton component
3. Enhance existing AssetForm with Plaid choice
4. Enhance existing LiabilityForm with Plaid choice
5. Handle both manual and Plaid creation flows

üìã DETAILED STEPS:

Step 3.1: Install Plaid Link for React
```bash
npm install react-plaid-link
npm install @types/react-plaid-link --save-dev
```

Step 3.2: Create src/components/PlaidLinkButton.tsx
```typescript
'use client'

import { usePlaidLink } from 'react-plaid-link';
import { Button } from '@/components/ui/button';
import { useState } from 'react';

interface PlaidLinkButtonProps {
  linkToken: string | null;
  onSuccess: (public_token: string, metadata: any) => void;
  onError?: (error: any) => void;
  buttonText?: string;
  className?: string;
}

export function PlaidLinkButton({
  linkToken,
  onSuccess,
  onError,
  buttonText = "Link to Bank Account",
  className
}: PlaidLinkButtonProps) {
  const [isLoading, setIsLoading] = useState(false);

  // üß† LEARNING: usePlaidLink hook handles the complex Plaid widget
  const { open, ready } = usePlaidLink({
    token: linkToken,
    onSuccess: (public_token, metadata) => {
      setIsLoading(true);
      onSuccess(public_token, metadata);
    },
    onExit: (err, metadata) => {
      setIsLoading(false);
      if (err) {
        console.error('Plaid Link exit error:', err);
        onError?.(err);
      }
    },
    onEvent: (eventName, metadata) => {
      // Optional: track events for analytics
      console.log('Plaid event:', eventName, metadata);
    },
  });

  return (
    <Button
      type="button"
      onClick={() => open()}
      disabled={!ready || !linkToken || isLoading}
      variant="outline"
      className={className}
    >
      {isLoading ? 'Connecting...' : buttonText}
    </Button>
  );
}
```

üß† WHY THIS PATTERN?
- The parent component provides the link token (keeps security logic higher up)
- onSuccess callback lets parent handle the result
- Disabled state prevents multiple clicks
- Loading state gives user feedback

Step 3.3: Create server action in src/app/actions.ts (add to existing file)
```typescript
// Add these imports to the top
import { createLinkToken, exchangePublicToken, getAccounts } from '@/lib/plaid';
import { createPlaidAccount } from '@/lib/plaid-accounts';

// üß† LEARNING: Server actions run on the server but can be called from client components
export async function createPlaidLinkTokenAction() {
  try {
    const user = await getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    const linkToken = await createLinkToken(user.id);
    return { success: true, linkToken };
  } catch (error) {
    console.error('Error creating link token:', error);
    return { success: false, error: 'Failed to create link token' };
  }
}

export async function exchangePlaidTokenAction(publicToken: string, metadata: any) {
  try {
    const user = await getUser();
    if (!user) {
      throw new Error('User not authenticated');
    }

    // üß† LEARNING: This is the key exchange - public token for access token
    const { accessToken, itemId } = await exchangePublicToken(publicToken);

    // Get account details from Plaid
    const accountsData = await getAccounts(accessToken);

    // Create database records for each account
    const createdAccounts = [];
    for (const account of accountsData.accounts) {
      const plaidAccount = await createPlaidAccount(user.id, {
        plaidAccountId: account.account_id,
        accessToken, // üö® In production, encrypt this!
        institutionId: accountsData.item.institution_id || '',
        institutionName: metadata.institution?.name || 'Unknown Bank',
        accountName: account.name,
        accountType: account.type,
        accountSubtype: account.subtype || undefined,
        mask: account.mask || undefined,
      });
      createdAccounts.push(plaidAccount);
    }

    return { success: true, accounts: createdAccounts };
  } catch (error) {
    console.error('Error exchanging Plaid token:', error);
    return { success: false, error: 'Failed to connect account' };
  }
}
```

Step 3.4: Enhance src/components/AssetForm.tsx (example enhancement)
```typescript
// Add these imports
import { useState, useEffect } from 'react';
import { PlaidLinkButton } from './PlaidLinkButton';
import { createPlaidLinkTokenAction } from '@/app/actions';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';

// Add to your existing AssetForm component:
export function AssetForm({ onSubmit, onCancel }: AssetFormProps) {
  const [entryMode, setEntryMode] = useState<'manual' | 'plaid'>('manual');
  const [linkToken, setLinkToken] = useState<string | null>(null);
  const [plaidData, setPlaidData] = useState<any>(null);

  // Initialize link token when component mounts
  useEffect(() => {
    async function initializeLinkToken() {
      const result = await createPlaidLinkTokenAction();
      if (result.success) {
        setLinkToken(result.linkToken);
      }
    }
    initializeLinkToken();
  }, []);

  const handlePlaidSuccess = (publicToken: string, metadata: any) => {
    // Store Plaid data for form submission
    setPlaidData({ publicToken, metadata });
    // Auto-fill form fields from Plaid data
    setValue('name', `${metadata.institution.name} ${metadata.accounts[0].name}`);
    setValue('value', 0); // Will be synced after connection
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Choice between manual and Plaid */}
      <div className="mb-6">
        <Label className="text-base font-medium">How would you like to track this asset?</Label>
        <RadioGroup value={entryMode} onValueChange={(value) => setEntryMode(value as 'manual' | 'plaid')} className="mt-2">
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="manual" id="manual" />
            <Label htmlFor="manual">Enter value manually</Label>
          </div>
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="plaid" id="plaid" />
            <Label htmlFor="plaid">Link to bank account (auto-sync)</Label>
          </div>
        </RadioGroup>
      </div>

      {/* Existing form fields */}
      <div className="space-y-4">
        <div>
          <Label htmlFor="name">Asset Name</Label>
          <Input
            id="name"
            {...register('name', { required: 'Asset name is required' })}
          />
          {errors.name && <p className="text-red-500 text-sm">{errors.name.message}</p>}
        </div>

        {/* Conditional value input vs Plaid button */}
        {entryMode === 'manual' ? (
          <div>
            <Label htmlFor="value">Value</Label>
            <Input
              id="value"
              type="number"
              step="0.01"
              {...register('value', { required: 'Value is required' })}
            />
            {errors.value && <p className="text-red-500 text-sm">{errors.value.message}</p>}
          </div>
        ) : (
          <div>
            <Label>Bank Account Connection</Label>
            {plaidData ? (
              <div className="p-3 bg-green-50 border border-green-200 rounded">
                <p className="text-green-700">‚úÖ Connected to {plaidData.metadata.institution.name}</p>
                <p className="text-sm text-green-600">Balance will be automatically synced</p>
              </div>
            ) : (
              <PlaidLinkButton
                linkToken={linkToken}
                onSuccess={handlePlaidSuccess}
                buttonText="Connect to Bank Account"
                className="w-full"
              />
            )}
          </div>
        )}

        {/* Rest of your existing form fields */}
      </div>

      {/* Submit button */}
      <div className="flex gap-2 mt-6">
        <Button type="submit" disabled={entryMode === 'plaid' && !plaidData}>
          {entryMode === 'plaid' && !plaidData ? 'Connect Account First' : 'Create Asset'}
        </Button>
        <Button type="button" variant="outline" onClick={onCancel}>
          Cancel
        </Button>
      </div>
    </form>
  );
}
```

üß† LEARNING NOTES:
- Server actions bridge client and server securely
- router.refresh() re-runs server components (updates the page with new data)
- Always handle errors gracefully - banks can be finicky!
- Link tokens expire, so we create them fresh each time

‚ñ∂Ô∏è PHASE 4: PLAID SYNC INTEGRATION (Day 3-4 - 2-3 hours)
================================================================================

üéØ Goal: Handle Plaid account creation and automatic balance syncing

üìù WHAT WE'RE DOING:
Building server actions to process Plaid connections from forms and sync balances
for assets/liabilities that users chose to link to their bank accounts.

üß† LEARNING FOCUS:
- Processing Plaid tokens from form submissions
- Creating assets/liabilities with Plaid data
- Automatic balance syncing for connected accounts
- Handling mixed manual and Plaid entries

‚úÖ TASKS:
1. Create server actions for Plaid-connected asset/liability creation
2. Build balance syncing functions
3. Add "Refresh Balances" functionality for connected accounts
4. Update existing CRUD operations to handle Plaid fields

üìã DETAILED STEPS:

Step 4.1: Create src/lib/plaid-sync.ts
```typescript
import { getAccountBalances } from './plaid';
import { updateAsset } from './assets';
import { updateLiability } from './liabilities';
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}
const prisma = globalForPrisma.prisma ?? new PrismaClient()
if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// üß† LEARNING: Sync balances for all Plaid-connected assets/liabilities
export async function syncUserPlaidBalances(userId: string) {
  try {
    // Get all assets and liabilities that are Plaid-synced
    const [plaidAssets, plaidLiabilities] = await Promise.all([
      prisma.asset.findMany({
        where: { userId, isPlaidSynced: true, plaidAccessToken: { not: null } }
      }),
      prisma.liability.findMany({
        where: { userId, isPlaidSynced: true, plaidAccessToken: { not: null } }
      })
    ]);

    const syncResults = [];
    const allPlaidAccounts = [...plaidAssets, ...plaidLiabilities];

    for (const account of allPlaidAccounts) {
      try {
        // Fetch fresh balance from Plaid
        const accounts = await getAccountBalances(account.plaidAccessToken!);
        const accountData = accounts.find(acc => acc.account_id === account.plaidAccountId);

        if (!accountData?.balances.current) {
          console.warn(`No balance data for account ${account.plaidAccountId}`);
          continue;
        }

        const newValue = Math.abs(accountData.balances.current); // Use absolute value
        const isAsset = 'assets' in prisma && await prisma.asset.findUnique({ where: { id: account.id } });

        if (isAsset) {
          await updateAsset(account.id, {
            value: newValue,
            lastSyncedAt: new Date()
          });
        } else {
          await updateLiability(account.id, {
            value: newValue,
            lastSyncedAt: new Date()
          });
        }

        syncResults.push({
          id: account.id,
          name: account.name,
          type: isAsset ? 'asset' : 'liability',
          success: true,
          oldValue: Number(account.value),
          newValue,
        });

      } catch (accountError) {
        console.error(`Error syncing account ${account.id}:`, accountError);
        syncResults.push({
          id: account.id,
          name: account.name,
          success: false,
          error: accountError.message,
        });
      }
    }

    return {
      success: true,
      results: syncResults,
      syncedAt: new Date(),
    };

  } catch (error) {
    console.error('Error syncing Plaid balances:', error);
    throw new Error('Failed to sync balances');
  }
}

// üß† LEARNING: Helper function to categorize accounts
export function getAssetCategory(accountType: string): string {
  switch (accountType) {
    case 'depository':
      return 'Cash';
    case 'investment':
    case 'brokerage':
      return 'Investments';
    default:
      return 'Other';
  }
}

export function getLiabilityCategory(accountType: string): string {
  switch (accountType) {
    case 'credit':
      return 'Credit Card';
    case 'loan':
      return 'Loan';
    case 'mortgage':
      return 'Mortgage';
    default:
      return 'Other';
  }
}

// Sync a single account (asset or liability)
export async function syncSingleAccount(accountId: string, type: 'asset' | 'liability') {
  try {
    const account = type === 'asset'
      ? await prisma.asset.findUnique({ where: { id: accountId } })
      : await prisma.liability.findUnique({ where: { id: accountId } });

    if (!account || !account.isPlaidSynced || !account.plaidAccessToken) {
      throw new Error('Account not found or not Plaid-synced');
    }

    const accounts = await getAccountBalances(account.plaidAccessToken);
    const accountData = accounts.find(acc => acc.account_id === account.plaidAccountId);

    if (!accountData?.balances.current) {
      throw new Error('No balance data available');
    }

    const newValue = Math.abs(accountData.balances.current);

    if (type === 'asset') {
      await updateAsset(accountId, { value: newValue, lastSyncedAt: new Date() });
    } else {
      await updateLiability(accountId, { value: newValue, lastSyncedAt: new Date() });
    }

    return {
      success: true,
      newBalance: newValue,
      syncedAt: new Date(),
    };

  } catch (error) {
    console.error('Error syncing single account:', error);
    throw error;
  }
}
```

Step 4.2: Add Plaid actions to src/app/actions.ts
```typescript
import { syncUserPlaidBalances } from '@/lib/plaid-sync';
import { exchangePublicToken, getAccounts } from '@/lib/plaid';
import { createAsset } from '@/lib/assets';
import { createLiability } from '@/lib/liabilities';

// Create asset with Plaid connection
export async function createPlaidAssetAction(formData: FormData, plaidData: any) {
  try {
    const user = await getUser();
    if (!user) throw new Error('User not authenticated');

    // Exchange Plaid public token for access token
    const { accessToken } = await exchangePublicToken(plaidData.publicToken);
    const accountsData = await getAccounts(accessToken);
    const accountInfo = accountsData.accounts[0]; // First selected account

    // Get current balance
    const balanceData = await getAccountBalances(accessToken);
    const currentBalance = balanceData[0]?.balances.current || 0;

    // Create asset with Plaid data
    const asset = await createAsset(user.id, {
      name: formData.get('name') as string,
      category: formData.get('category') as string,
      value: Math.abs(currentBalance),
      description: formData.get('description') as string || `Auto-synced from ${plaidData.metadata.institution.name}`,
      // Plaid fields
      plaidAccountId: accountInfo.account_id,
      plaidAccessToken: accessToken, // üö® Encrypt in production!
      institutionName: plaidData.metadata.institution.name,
      isPlaidSynced: true,
    });

    return { success: true, asset };
  } catch (error) {
    console.error('Error creating Plaid asset:', error);
    return { success: false, error: error.message };
  }
}

// Similar function for liabilities
export async function createPlaidLiabilityAction(formData: FormData, plaidData: any) {
  try {
    const user = await getUser();
    if (!user) throw new Error('User not authenticated');

    const { accessToken } = await exchangePublicToken(plaidData.publicToken);
    const accountsData = await getAccounts(accessToken);
    const accountInfo = accountsData.accounts[0];

    const balanceData = await getAccountBalances(accessToken);
    const currentBalance = balanceData[0]?.balances.current || 0;

    const liability = await createLiability(user.id, {
      name: formData.get('name') as string,
      category: formData.get('category') as string,
      value: Math.abs(currentBalance), // Liabilities are positive values
      description: formData.get('description') as string || `Auto-synced from ${plaidData.metadata.institution.name}`,
      // Plaid fields
      plaidAccountId: accountInfo.account_id,
      plaidAccessToken: accessToken,
      institutionName: plaidData.metadata.institution.name,
      isPlaidSynced: true,
    });

    return { success: true, liability };
  } catch (error) {
    console.error('Error creating Plaid liability:', error);
    return { success: false, error: error.message };
  }
}

// Sync all Plaid balances
export async function syncPlaidBalancesAction() {
  try {
    const user = await getUser();
    if (!user) throw new Error('User not authenticated');

    const result = await syncUserPlaidBalances(user.id);
    return { success: true, data: result };
  } catch (error) {
    console.error('Error in sync action:', error);
    return { success: false, error: error.message };
  }
}
```

Step 4.3: Create src/components/PlaidSyncButton.tsx
```typescript
'use client'

import { useState } from 'react';
import { Button } from './ui/button';
import { syncPlaidBalancesAction } from '@/app/actions';
import { useRouter } from 'next/navigation';
import { RefreshCw } from 'lucide-react';

interface PlaidSyncButtonProps {
  className?: string;
}

export function PlaidSyncButton({ className }: PlaidSyncButtonProps) {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handleSync = async () => {
    setIsLoading(true);

    try {
      const result = await syncPlaidBalancesAction();

      if (result.success) {
        // Show success message
        const { results } = result.data;
        const successCount = results.filter(r => r.success).length;
        alert(`Successfully synced ${successCount} account(s)!`);

        // Refresh the page to show updated balances
        router.refresh();
      } else {
        alert(`Sync failed: ${result.error}`);
      }
    } catch (error) {
      console.error('Sync error:', error);
      alert('Failed to sync balances. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button
      onClick={handleSync}
      disabled={isLoading}
      variant="outline"
      size="sm"
      className={className}
    >
      <RefreshCw className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
      {isLoading ? 'Syncing...' : 'Refresh Balances'}
    </Button>
  );
}
```

üß† LEARNING NOTES:
- We sync all accounts at once for simplicity
- Real apps might do this in background jobs
- Always handle partial failures gracefully
- User feedback is crucial for external API calls

‚ñ∂Ô∏è PHASE 5: ENHANCED DASHBOARD & UI (Day 4-5 - 2-3 hours)
================================================================================

üéØ Goal: Update dashboard and lists to show sync status for connected accounts

üìù WHAT WE'RE DOING:
Enhancing your existing AssetsList and LiabilitiesList components to show which
accounts are manually entered vs auto-synced from bank accounts.

üß† LEARNING FOCUS:
- Conditional rendering for different data sources
- Visual indicators for sync status
- Unified UI that handles both manual and Plaid entries
- User feedback for sync operations

‚úÖ TASKS:
1. Add sync status indicators to existing asset/liability lists
2. Show last sync timestamps for connected accounts
3. Add "Refresh Balances" functionality
4. Update dashboard totals to include both manual and synced values

üìã DETAILED STEPS:

Step 5.1: Enhance src/components/AssetsList.tsx (example enhancement)
```typescript
// Add these imports to your existing AssetsList
import { Badge } from './ui/badge';
import { Button } from './ui/button';
import { RefreshCw, Link2, Edit3 } from 'lucide-react';
import { syncSingleAccount } from '@/lib/plaid-sync';
import { useState } from 'react';

// Enhance your existing AssetsList component:
export function AssetsList({ assets, onEdit, onDelete }: AssetsListProps) {
  const [syncing, setSyncing] = useState<string | null>(null);

  const handleSyncSingle = async (assetId: string) => {
    setSyncing(assetId);
    try {
      await syncSingleAccount(assetId, 'asset');
      // Refresh the page or update local state
      window.location.reload(); // Simple approach
    } catch (error) {
      console.error('Sync failed:', error);
      alert('Failed to sync balance. Please try again.');
    } finally {
      setSyncing(null);
    }
  };

  return (
    <div className="space-y-3">
      {assets.map((asset) => (
        <div key={asset.id} className="flex items-center justify-between p-4 border rounded-lg">
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-1">
              <h3 className="font-medium">{asset.name}</h3>

              {/* NEW: Sync status badges */}
              {asset.isPlaidSynced ? (
                <Badge variant="secondary" className="text-xs bg-blue-50 text-blue-700">
                  <Link2 className="w-3 h-3 mr-1" />
                  {asset.institutionName}
                </Badge>
              ) : (
                <Badge variant="outline" className="text-xs">
                  <Edit3 className="w-3 h-3 mr-1" />
                  Manual
                </Badge>
              )}
            </div>

            <p className="text-sm text-muted-foreground">
              {asset.category} ‚Ä¢ {formatCurrency(Number(asset.value))}
            </p>

            {/* NEW: Show last sync time for Plaid accounts */}
            {asset.isPlaidSynced && asset.lastSyncedAt && (
              <p className="text-xs text-muted-foreground mt-1">
                Last synced: {new Date(asset.lastSyncedAt).toLocaleString()}
              </p>
            )}

            {asset.description && (
              <p className="text-xs text-muted-foreground mt-1">{asset.description}</p>
            )}
          </div>

          <div className="flex items-center gap-2">
            {/* NEW: Sync button for Plaid accounts */}
            {asset.isPlaidSynced && (
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleSyncSingle(asset.id)}
                disabled={syncing === asset.id}
                className="h-8 w-8 p-0"
              >
                <RefreshCw className={`w-4 h-4 ${syncing === asset.id ? 'animate-spin' : ''}`} />
              </Button>
            )}

            {/* Existing edit/delete buttons - only show for manual entries */}
            {!asset.isPlaidSynced && (
              <>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => onEdit(asset)}
                  className="h-8 w-8 p-0"
                >
                  <Edit3 className="w-4 h-4" />
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => onDelete(asset.id)}
                  className="h-8 w-8 p-0 text-destructive hover:text-destructive"
                >
                  <Trash2 className="w-4 h-4" />
                </Button>
              </>
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
```

Step 5.2: Update src/app/page.tsx (minimal changes needed)
```typescript
// Add just the sync button import
import { PlaidSyncButton } from '@/components/PlaidSyncButton';

// Your existing page component stays mostly the same
export default async function Home() {
  const user = await getUser();
  if (!user) redirect("/auth");

  // Existing data fetching (no changes needed)
  const [assets, liabilities] = await Promise.all([
    getUserAssetsAction(),
    getUserLiabilitiesAction()
  ]);

  // Calculate totals (includes both manual and Plaid-synced assets/liabilities)
  const totalAssets = calculateTotalAssets(assets);
  const totalLiabilities = calculateTotalLiabilities(liabilities);
  const netWorth = calculateNetWorth(totalAssets, totalLiabilities);

  return (
    <div className="min-h-screen p-6 lg:p-8">
      <div className="max-w-7xl mx-auto">
        {/* Header section - just add sync button */}
        <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-10">
          <div className="mb-4 sm:mb-0">
            <h1 className="heading-xl bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
              Net Worth Tracker
            </h1>
            <p className="text-muted-foreground mt-2">
              Track your financial progress and build wealth
            </p>
          </div>
          <div className="flex items-center gap-4">
            {/* NEW: Add sync button for Plaid accounts */}
            <PlaidSyncButton />
            <div className="text-right hidden sm:block">
              <p className="text-sm text-muted-foreground">Welcome back</p>
              <p className="font-medium">{user.email}</p>
            </div>
            <form action={signOut}>
              <Button variant="outline" type="submit" className="btn-financial">
                Sign Out
              </Button>
            </form>
          </div>
        </div>

        {/* Summary cards (no changes - totals automatically include Plaid accounts) */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-10 animate-fade-in">
          {/* Your existing summary cards work perfectly */}
        </div>

        {/* Your existing DashboardClient - enhanced lists will show sync status */}
        <DashboardClient initialAssets={assets} initialLiabilities={liabilities} />
      </div>
    </div>
  );
}
```

Step 5.3: Create src/components/PlaidSyncButton.tsx (global sync button)
```typescript
'use client'

import { useState } from 'react';
import { Button } from './ui/button';
import { syncPlaidBalancesAction } from '@/app/actions';
import { useRouter } from 'next/navigation';
import { RefreshCw } from 'lucide-react';

interface PlaidSyncButtonProps {
  className?: string;
}

export function PlaidSyncButton({ className }: PlaidSyncButtonProps) {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handleSyncAll = async () => {
    setIsLoading(true);

    try {
      const result = await syncPlaidBalancesAction();

      if (result.success) {
        const { results } = result.data;
        const successCount = results.filter(r => r.success).length;
        const totalCount = results.length;

        if (totalCount === 0) {
          alert('No connected accounts to sync.');
        } else {
          alert(`Synced ${successCount} of ${totalCount} connected account(s)!`);
        }

        // Refresh to show updated balances
        router.refresh();
      } else {
        alert(`Sync failed: ${result.error}`);
      }
    } catch (error) {
      console.error('Sync error:', error);
      alert('Failed to sync balances. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Button
      onClick={handleSyncAll}
      disabled={isLoading}
      variant="outline"
      size="sm"
      className={className}
    >
      <RefreshCw className={`w-4 h-4 mr-2 ${isLoading ? 'animate-spin' : ''}`} />
      {isLoading ? 'Syncing...' : 'Refresh Connected Balances'}
    </Button>
  );
}
```

üß† LEARNING NOTES:
- All assets/liabilities show in same lists with clear visual indicators
- Manual entries can be edited/deleted, Plaid entries can only be synced
- Sync timestamps show when bank data was last refreshed
- Users get both individual sync (per account) and bulk sync (all accounts)
- Totals automatically include both manual and Plaid-synced values

================================================================================
5. TROUBLESHOOTING & COMMON ISSUES
================================================================================

üêõ COMMON PROBLEMS & SOLUTIONS:

Problem: "Invalid credentials" error
Solution: Double-check your PLAID_CLIENT_ID and PLAID_SECRET in .env

Problem: Link token expires
Solution: Link tokens are short-lived (30 min). Generate fresh ones.

Problem: Access token becomes invalid
Solution: Banks can revoke access. Handle this gracefully and prompt re-connection.

Problem: Balance shows as null
Solution: Not all banks provide all balance types. Check for null values.

Problem: Migration fails
Solution: Check your schema syntax and ensure Prisma CLI is updated.

Problem: "Module not found" errors
Solution: Restart your dev server after installing new packages.

üîç DEBUGGING TIPS:
1. Check browser console for client-side errors
2. Check server logs for API errors
3. Use Plaid's dashboard to monitor API calls
4. Test with Plaid's sandbox accounts first

================================================================================
6. RESOURCES & DOCUMENTATION
================================================================================

üìö ESSENTIAL READING:
- Plaid Quickstart: https://plaid.com/docs/quickstart/
- Plaid Link Guide: https://plaid.com/docs/link/
- Balance API Reference: https://plaid.com/docs/api/products/balance/
- React Plaid Link: https://github.com/plaid/react-plaid-link

üõ†Ô∏è TOOLS:
- Plaid Dashboard: https://dashboard.plaid.com/
- Plaid Postman Collection: Test APIs manually
- Plaid Support: help@plaid.com

üè¶ SANDBOX TEST ACCOUNTS:
Username: user_good
Password: pass_good
(This gives you fake accounts to test with)

================================================================================
PHASE SUMMARY & NEXT STEPS
================================================================================

‚úÖ AFTER PHASE 5, YOU'LL HAVE:
- User choice workflow: Manual OR Plaid linking per asset/liability
- Enhanced Asset/Liability forms with Plaid connection option
- Real-time balance syncing for connected accounts
- Unified dashboard showing all accounts with clear sync indicators
- Individual and bulk sync functionality
- Proper error handling and user feedback

üöÄ FUTURE ENHANCEMENTS:
- Automatic scheduled syncing (background jobs)
- Transaction history import
- Categorization improvements
- Account disconnection flows
- Better error recovery

üéì SKILLS YOU'VE LEARNED:
- Third-party API integration (Plaid)
- OAuth-like token flows (Link ‚Üí Public ‚Üí Access tokens)
- Database schema evolution and optional fields
- Conditional form rendering and user choice workflows
- React component enhancement patterns
- State management for mixed data sources
- Error handling strategies for external APIs
- User experience design for optional features

Remember: Start with Phase 1 and test each phase thoroughly before moving on!